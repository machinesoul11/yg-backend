/**
 * 2FA Compliance Service
 * 
 * Handles compliance tracking and metrics aggregation for two-factor authentication.
 * 
 * Features:
 * - Track 2FA adoption rates by role and overall
 * - Monitor authentication success/failure rates
 * - Calculate compliance metrics for reporting
 * - Track backup code usage and regeneration patterns
 * - Historical trend analysis
 */

import { PrismaClient, UserRole } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';

export interface AdoptionMetrics {
  totalUsers: number;
  usersWithTwoFactor: number;
  adoptionRate: number;
  byRole: {
    [key in UserRole]: {
      total: number;
      enabled: number;
      rate: number;
    };
  };
}

export interface AuthenticationMetrics {
  totalAttempts: number;
  successful: number;
  failed: number;
  failureRate: number;
  byMethod: {
    totp: number;
    sms: number;
    backupCode: number;
  };
}

export interface SecurityMetrics {
  accountLockouts: number;
  suspiciousActivities: number;
  emergencyCodesGenerated: number;
  adminResets: number;
  backupCodesRegenerated: number;
  usersWithLowBackupCodes: number;
}

export interface ComplianceSnapshot {
  adoption: AdoptionMetrics;
  authentication: AuthenticationMetrics;
  security: SecurityMetrics;
  periodStart: Date;
  periodEnd: Date;
}

export class TwoFactorComplianceService {
  constructor(private prisma: PrismaClient) {}

  /**
   * Get current 2FA adoption metrics
   */
  async getCurrentAdoptionMetrics(): Promise<AdoptionMetrics> {
    const totalUsers = await this.prisma.user.count({
      where: { deleted_at: null },
    });

    const usersWithTwoFactor = await this.prisma.user.count({
      where: {
        deleted_at: null,
        two_factor_enabled: true,
      },
    });

    const adoptionRate = totalUsers > 0 ? (usersWithTwoFactor / totalUsers) * 100 : 0;

    // Get breakdown by role
    const roles: UserRole[] = ['ADMIN', 'CREATOR', 'BRAND', 'TALENT', 'VIEWER'];
    const byRole: any = {};

    for (const role of roles) {
      const total = await this.prisma.user.count({
        where: { deleted_at: null, role },
      });

      const enabled = await this.prisma.user.count({
        where: {
          deleted_at: null,
          role,
          two_factor_enabled: true,
        },
      });

      byRole[role] = {
        total,
        enabled,
        rate: total > 0 ? (enabled / total) * 100 : 0,
      };
    }

    return {
      totalUsers,
      usersWithTwoFactor,
      adoptionRate,
      byRole,
    };
  }

  /**
   * Calculate authentication metrics for a time period
   */
  async getAuthenticationMetrics(
    startDate: Date,
    endDate: Date
  ): Promise<AuthenticationMetrics> {
    // Get all 2FA events in the period
    const events = await this.prisma.twoFactorSecurityEvent.findMany({
      where: {
        timestamp: {
          gte: startDate,
          lte: endDate,
        },
        eventCategory: 'authentication',
      },
      select: {
        success: true,
        method: true,
      },
    });

    const totalAttempts = events.length;
    const successful = events.filter(e => e.success).length;
    const failed = totalAttempts - successful;
    const failureRate = totalAttempts > 0 ? (failed / totalAttempts) * 100 : 0;

    const byMethod = {
      totp: events.filter(e => e.method === 'totp').length,
      sms: events.filter(e => e.method === 'sms').length,
      backupCode: events.filter(e => e.method === 'backup_code').length,
    };

    return {
      totalAttempts,
      successful,
      failed,
      failureRate,
      byMethod,
    };
  }

  /**
   * Get security-related metrics for a time period
   */
  async getSecurityMetrics(startDate: Date, endDate: Date): Promise<SecurityMetrics> {
    // Account lockouts
    const accountLockouts = await this.prisma.twoFactorSecurityEvent.count({
      where: {
        timestamp: { gte: startDate, lte: endDate },
        eventType: 'lockout',
      },
    });

    // Suspicious activities
    const suspiciousActivities = await this.prisma.twoFactorSecurityEvent.count({
      where: {
        timestamp: { gte: startDate, lte: endDate },
        isAnomalous: true,
      },
    });

    // Emergency codes generated by admins
    const emergencyCodesGenerated = await this.prisma.adminEmergencyCode.count({
      where: {
        createdAt: { gte: startDate, lte: endDate },
      },
    });

    // Admin resets
    const adminResets = await this.prisma.twoFactorSecurityEvent.count({
      where: {
        timestamp: { gte: startDate, lte: endDate },
        eventType: 'admin_reset',
      },
    });

    // Backup codes regenerated
    const backupCodesRegenerated = await this.prisma.twoFactorSecurityEvent.count({
      where: {
        timestamp: { gte: startDate, lte: endDate },
        eventType: 'backup_code_regeneration',
      },
    });

    // Users with low backup codes (less than 3)
    const usersWithBackupCodes = await this.prisma.user.findMany({
      where: {
        deleted_at: null,
        two_factor_enabled: true,
      },
      select: {
        id: true,
        twoFactorBackupCodes: {
          where: { used: false },
          select: { id: true },
        },
      },
    });

    const usersWithLowBackupCodes = usersWithBackupCodes.filter(
      u => u.twoFactorBackupCodes.length < 3
    ).length;

    return {
      accountLockouts,
      suspiciousActivities,
      emergencyCodesGenerated,
      adminResets,
      backupCodesRegenerated,
      usersWithLowBackupCodes,
    };
  }

  /**
   * Aggregate compliance metrics for a period and store them
   */
  async aggregateComplianceMetrics(
    periodStart: Date,
    periodEnd: Date,
    periodType: 'daily' | 'weekly' | 'monthly'
  ): Promise<void> {
    console.log(`[ComplianceService] Aggregating metrics for ${periodType} period:`, {
      periodStart,
      periodEnd,
    });

    const adoption = await this.getCurrentAdoptionMetrics();
    const authentication = await this.getAuthenticationMetrics(periodStart, periodEnd);
    const security = await this.getSecurityMetrics(periodStart, periodEnd);

    // Get backup code usage stats
    const backupCodesUsed = await this.prisma.twoFactorBackupCode.count({
      where: {
        used: true,
        usedAt: {
          gte: periodStart,
          lte: periodEnd,
        },
      },
    });

    // Check for previous period to calculate trends
    const previousPeriod = await this.getPreviousPeriodMetrics(periodStart, periodType);

    const adoptionRateChange = previousPeriod
      ? adoption.adoptionRate - previousPeriod.adoptionRate.toNumber()
      : null;

    const failureRateChange = previousPeriod
      ? authentication.failureRate - previousPeriod.failureRate.toNumber()
      : null;

    // Store aggregated metrics
    await this.prisma.twoFactorComplianceMetrics.upsert({
      where: {
        periodStart_periodEnd_periodType: {
          periodStart,
          periodEnd,
          periodType,
        },
      },
      create: {
        periodStart,
        periodEnd,
        periodType,
        totalUsers: adoption.totalUsers,
        usersWithTwoFactor: adoption.usersWithTwoFactor,
        adoptionRate: new Decimal(adoption.adoptionRate),
        adminTotal: adoption.byRole.ADMIN.total,
        adminEnabled: adoption.byRole.ADMIN.enabled,
        creatorTotal: adoption.byRole.CREATOR.total,
        creatorEnabled: adoption.byRole.CREATOR.enabled,
        brandTotal: adoption.byRole.BRAND.total,
        brandEnabled: adoption.byRole.BRAND.enabled,
        talentTotal: adoption.byRole.TALENT.total,
        talentEnabled: adoption.byRole.TALENT.enabled,
        viewerTotal: adoption.byRole.VIEWER.total,
        viewerEnabled: adoption.byRole.VIEWER.enabled,
        totalAuthAttempts: authentication.totalAttempts,
        successfulAuths: authentication.successful,
        failedAuths: authentication.failed,
        failureRate: new Decimal(authentication.failureRate),
        totpAttempts: authentication.byMethod.totp,
        smsAttempts: authentication.byMethod.sms,
        backupCodeAttempts: authentication.byMethod.backupCode,
        accountLockouts: security.accountLockouts,
        suspiciousActivities: security.suspiciousActivities,
        emergencyCodesGenerated: security.emergencyCodesGenerated,
        adminResets: security.adminResets,
        backupCodesRegenerated: security.backupCodesRegenerated,
        usersWithLowBackupCodes: security.usersWithLowBackupCodes,
        backupCodesUsed,
        adoptionRateChange: adoptionRateChange !== null ? new Decimal(adoptionRateChange) : null,
        failureRateChange: failureRateChange !== null ? new Decimal(failureRateChange) : null,
      },
      update: {
        totalUsers: adoption.totalUsers,
        usersWithTwoFactor: adoption.usersWithTwoFactor,
        adoptionRate: new Decimal(adoption.adoptionRate),
        adminTotal: adoption.byRole.ADMIN.total,
        adminEnabled: adoption.byRole.ADMIN.enabled,
        creatorTotal: adoption.byRole.CREATOR.total,
        creatorEnabled: adoption.byRole.CREATOR.enabled,
        brandTotal: adoption.byRole.BRAND.total,
        brandEnabled: adoption.byRole.BRAND.enabled,
        talentTotal: adoption.byRole.TALENT.total,
        talentEnabled: adoption.byRole.TALENT.enabled,
        viewerTotal: adoption.byRole.VIEWER.total,
        viewerEnabled: adoption.byRole.VIEWER.enabled,
        totalAuthAttempts: authentication.totalAttempts,
        successfulAuths: authentication.successful,
        failedAuths: authentication.failed,
        failureRate: new Decimal(authentication.failureRate),
        totpAttempts: authentication.byMethod.totp,
        smsAttempts: authentication.byMethod.sms,
        backupCodeAttempts: authentication.byMethod.backupCode,
        accountLockouts: security.accountLockouts,
        suspiciousActivities: security.suspiciousActivities,
        emergencyCodesGenerated: security.emergencyCodesGenerated,
        adminResets: security.adminResets,
        backupCodesRegenerated: security.backupCodesRegenerated,
        usersWithLowBackupCodes: security.usersWithLowBackupCodes,
        backupCodesUsed,
        adoptionRateChange: adoptionRateChange !== null ? new Decimal(adoptionRateChange) : null,
        failureRateChange: failureRateChange !== null ? new Decimal(failureRateChange) : null,
      },
    });

    console.log(`[ComplianceService] ✓ Metrics aggregated for ${periodType} period`);
  }

  /**
   * Get metrics from previous period for trend comparison
   */
  private async getPreviousPeriodMetrics(
    currentPeriodStart: Date,
    periodType: 'daily' | 'weekly' | 'monthly'
  ) {
    let previousPeriodStart: Date;

    switch (periodType) {
      case 'daily':
        previousPeriodStart = new Date(currentPeriodStart);
        previousPeriodStart.setDate(previousPeriodStart.getDate() - 1);
        break;
      case 'weekly':
        previousPeriodStart = new Date(currentPeriodStart);
        previousPeriodStart.setDate(previousPeriodStart.getDate() - 7);
        break;
      case 'monthly':
        previousPeriodStart = new Date(currentPeriodStart);
        previousPeriodStart.setMonth(previousPeriodStart.getMonth() - 1);
        break;
    }

    return this.prisma.twoFactorComplianceMetrics.findFirst({
      where: {
        periodStart: previousPeriodStart,
        periodType,
      },
    });
  }

  /**
   * Get compliance metrics for a date range
   */
  async getMetricsByDateRange(startDate: Date, endDate: Date) {
    return this.prisma.twoFactorComplianceMetrics.findMany({
      where: {
        periodStart: {
          gte: startDate,
          lte: endDate,
        },
      },
      orderBy: {
        periodStart: 'desc',
      },
    });
  }

  /**
   * Get adoption trend data for charts
   */
  async getAdoptionTrend(days: number = 30) {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const metrics = await this.prisma.twoFactorComplianceMetrics.findMany({
      where: {
        periodStart: {
          gte: startDate,
          lte: endDate,
        },
        periodType: 'daily',
      },
      orderBy: {
        periodStart: 'asc',
      },
      select: {
        periodStart: true,
        adoptionRate: true,
        totalUsers: true,
        usersWithTwoFactor: true,
      },
    });

    return metrics.map(m => ({
      date: m.periodStart.toISOString().split('T')[0],
      adoptionRate: m.adoptionRate.toNumber(),
      totalUsers: m.totalUsers,
      usersWithTwoFactor: m.usersWithTwoFactor,
    }));
  }

  /**
   * Get failed attempts trend
   */
  async getFailedAttemptsTrend(days: number = 30) {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const metrics = await this.prisma.twoFactorComplianceMetrics.findMany({
      where: {
        periodStart: {
          gte: startDate,
          lte: endDate,
        },
        periodType: 'daily',
      },
      orderBy: {
        periodStart: 'asc',
      },
      select: {
        periodStart: true,
        failedAuths: true,
        totalAuthAttempts: true,
        failureRate: true,
      },
    });

    return metrics.map(m => ({
      date: m.periodStart.toISOString().split('T')[0],
      failedAuths: m.failedAuths,
      totalAttempts: m.totalAuthAttempts,
      failureRate: m.failureRate.toNumber(),
    }));
  }
}
