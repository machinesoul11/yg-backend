/**
 * Enhanced Financial Report PDF Service
 * 
 * Extends the existing PDF service with professional templates specifically
 * for export and distribution of financial data reports with YesGoddess branding.
 */

import { PrismaClient } from '@prisma/client';
import PDFDocument from 'pdfkit';
import { format } from 'date-fns';

export interface FinancialReportPDFConfig {
  reportType: 'royalty_statements' | 'transaction_ledger' | 'creator_earnings' | 'platform_revenue' | 'payout_summary';
  title: string;
  subtitle?: string;
  dateRange: {
    startDate: Date;
    endDate: Date;
  };
  generatedBy: string;
  includeCharts?: boolean;
  includeSummary?: boolean;
  watermark?: string;
}

export interface PDFSection {
  title: string;
  content: any;
  type: 'summary' | 'table' | 'chart' | 'text';
}

export class FinancialReportPDFService {
  private readonly brandColors = {
    VOID: '#0A0A0A',
    BONE: '#C4C0B8', 
    SANCTUM: '#B8A888',
    ALTAR: '#B8A888'
  };

  private readonly fonts = {
    title: 20,
    subtitle: 16,
    heading: 14,
    subheading: 12,
    body: 10,
    caption: 8
  };

  constructor(private readonly prisma: PrismaClient) {}

  /**
   * Generate PDF report for financial data
   */
  async generateFinancialReportPDF(
    config: FinancialReportPDFConfig,
    data: any
  ): Promise<Buffer> {
    const doc = new PDFDocument({
      size: 'LETTER',
      margins: { top: 72, bottom: 72, left: 72, right: 72 },
      info: {
        Title: config.title,
        Author: 'YesGoddess Platform',
        Subject: `${config.reportType.replace('_', ' ').toUpperCase()} Report`,
        Creator: 'YesGoddess Financial Analytics',
        Producer: 'YesGoddess Platform'
      }
    });

    const chunks: Buffer[] = [];
    doc.on('data', chunk => chunks.push(chunk));

    await this.generateCoverPage(doc, config);
    
    if (config.includeSummary) {
      this.addNewPage(doc);
      await this.generateSummaryPage(doc, config, data);
    }

    this.addNewPage(doc);
    await this.generateDataPages(doc, config, data);

    this.addNewPage(doc);
    this.generateAppendixPage(doc, config);

    doc.end();

    return new Promise((resolve) => {
      doc.on('end', () => {
        resolve(Buffer.concat(chunks));
      });
    });
  }

  /**
   * Generate cover page
   */
  private async generateCoverPage(doc: InstanceType<typeof PDFDocument>, config: FinancialReportPDFConfig) {
    // YesGoddess branding header
    doc.fontSize(this.fonts.title)
       .fillColor(this.brandColors.VOID)
       .text('YES GODDESS', { align: 'center' });

    doc.moveDown(0.5);
    doc.fontSize(this.fonts.subtitle)
       .fillColor(this.brandColors.BONE)
       .text('Financial Analytics Platform', { align: 'center' });

    doc.moveDown(2);

    // Report title
    doc.fontSize(this.fonts.title)
       .fillColor(this.brandColors.VOID)
       .text(config.title, { align: 'center' });

    if (config.subtitle) {
      doc.moveDown(0.5);
      doc.fontSize(this.fonts.subtitle)
         .fillColor(this.brandColors.BONE)
         .text(config.subtitle, { align: 'center' });
    }

    doc.moveDown(2);

    // Period box
    const periodText = `${format(config.dateRange.startDate, 'MMMM dd, yyyy')} - ${format(config.dateRange.endDate, 'MMMM dd, yyyy')}`;
    
    const boxWidth = 300;
    const boxHeight = 60;
    const boxX = (doc.page.width - boxWidth) / 2;
    const boxY = doc.y;

    doc.rect(boxX, boxY, boxWidth, boxHeight)
       .fill(this.brandColors.SANCTUM);

    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.heading)
       .text('REPORTING PERIOD', boxX, boxY + 15, { width: boxWidth, align: 'center' });

    doc.fontSize(this.fonts.subheading)
       .text(periodText, boxX, boxY + 35, { width: boxWidth, align: 'center' });

    doc.y = boxY + boxHeight + 40;

    // Generation info
    doc.fillColor(this.brandColors.BONE)
       .fontSize(this.fonts.body)
       .text(`Generated: ${format(new Date(), 'MMMM dd, yyyy HH:mm')}`, { align: 'center' });

    doc.moveDown(0.5);
    doc.text(`Generated by: ${config.generatedBy}`, { align: 'center' });

    // Footer with brand message
    doc.y = doc.page.height - 150;
    doc.fillColor(this.brandColors.BONE)
       .fontSize(this.fonts.caption)
       .text('CONFIDENTIAL FINANCIAL REPORT', { align: 'center' });

    doc.moveDown(0.5);
    doc.text('This document contains proprietary financial information.', { align: 'center' });
    doc.text('Distribution is restricted to authorized personnel only.', { align: 'center' });

    doc.moveDown(2);
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.body)
       .text('YES GODDESS', { align: 'center' });
    doc.fontSize(this.fonts.caption)
       .text('The initiated know.', { align: 'center' });
  }

  /**
   * Generate summary page
   */
  private async generateSummaryPage(
    doc: InstanceType<typeof PDFDocument>, 
    config: FinancialReportPDFConfig, 
    data: any
  ) {
    this.addPageHeader(doc, 'Executive Summary');

    const metrics = await this.calculateSummaryMetrics(config, data);

    // Key metrics grid
    const gridStartY = doc.y + 20;
    const boxWidth = 120;
    const boxHeight = 80;
    const spacing = 20;

    metrics.forEach((metric, index) => {
      const col = index % 4;
      const row = Math.floor(index / 4);
      
      const x = 72 + col * (boxWidth + spacing);
      const y = gridStartY + row * (boxHeight + spacing);

      // Metric box
      doc.rect(x, y, boxWidth, boxHeight)
         .fill(this.brandColors.BONE);

      doc.fillColor(this.brandColors.VOID)
         .fontSize(this.fonts.caption)
         .text(metric.label, x + 10, y + 10, { width: boxWidth - 20, align: 'center' });

      doc.fontSize(this.fonts.subheading)
         .text(metric.value, x + 10, y + 35, { width: boxWidth - 20, align: 'center' });

      if (metric.change) {
        const changeColor = metric.change.startsWith('+') ? '#059669' : '#dc2626';
        doc.fillColor(changeColor)
           .fontSize(this.fonts.caption)
           .text(metric.change, x + 10, y + 55, { width: boxWidth - 20, align: 'center' });
      }
    });

    doc.y = gridStartY + Math.ceil(metrics.length / 4) * (boxHeight + spacing) + 40;

    // Summary insights
    this.addSectionHeader(doc, 'Key Insights');
    const insights = this.generateInsights(config.reportType, data);
    
    insights.forEach(insight => {
      doc.fillColor(this.brandColors.VOID)
         .fontSize(this.fonts.body)
         .text(`• ${insight}`, { paragraphGap: 5 });
    });
  }

  /**
   * Generate data pages
   */
  private async generateDataPages(
    doc: InstanceType<typeof PDFDocument>,
    config: FinancialReportPDFConfig,
    data: any
  ) {
    this.addPageHeader(doc, 'Detailed Analysis');

    switch (config.reportType) {
      case 'royalty_statements':
        await this.generateRoyaltyStatementsPages(doc, data);
        break;
      case 'transaction_ledger':
        await this.generateTransactionLedgerPages(doc, data);
        break;
      case 'creator_earnings':
        await this.generateCreatorEarningsPages(doc, data);
        break;
      case 'platform_revenue':
        await this.generatePlatformRevenuePages(doc, data);
        break;
      case 'payout_summary':
        await this.generatePayoutSummaryPages(doc, data);
        break;
    }
  }

  /**
   * Generate appendix page
   */
  private generateAppendixPage(doc: InstanceType<typeof PDFDocument>, config: FinancialReportPDFConfig) {
    this.addPageHeader(doc, 'Appendix');

    this.addSectionHeader(doc, 'Report Methodology');
    
    const methodology = [
      'Data Sources: All financial data is sourced from the YesGoddess platform database',
      'Currency: All monetary amounts are displayed in USD unless otherwise specified',
      'Calculations: Revenue and royalty calculations follow platform-standard algorithms',
      'Time Zones: All timestamps are in UTC and converted to platform local time',
      'Accuracy: Financial data is accurate as of the report generation timestamp'
    ];

    methodology.forEach(point => {
      doc.fillColor(this.brandColors.VOID)
         .fontSize(this.fonts.body)
         .text(`• ${point}`, { paragraphGap: 5 });
    });

    doc.moveDown(2);

    this.addSectionHeader(doc, 'Definitions');
    
    const definitions = this.getDefinitionsForReportType(config.reportType);
    
    definitions.forEach(def => {
      doc.fillColor(this.brandColors.VOID)
         .fontSize(this.fonts.body)
         .text(`${def.term}: `, { continued: true })
         .fillColor(this.brandColors.BONE)
         .text(def.definition, { paragraphGap: 8 });
    });

    // Footer
    doc.y = doc.page.height - 100;
    doc.fillColor(this.brandColors.BONE)
       .fontSize(this.fonts.caption)
       .text('For questions about this report, contact: finance@yesgoddess.com', { align: 'center' });
  }

  /**
   * Add page header
   */
  private addPageHeader(doc: InstanceType<typeof PDFDocument>, title: string) {
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.heading)
       .text(title, 72, 72);

    // Underline
    doc.moveTo(72, doc.y + 5)
       .lineTo(doc.page.width - 72, doc.y + 5)
       .stroke(this.brandColors.SANCTUM);

    doc.moveDown(1);
  }

  /**
   * Add section header
   */
  private addSectionHeader(doc: InstanceType<typeof PDFDocument>, title: string) {
    doc.moveDown(1);
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.subheading)
       .text(title);
    doc.moveDown(0.5);
  }

  /**
   * Add new page
   */
  private addNewPage(doc: InstanceType<typeof PDFDocument>) {
    doc.addPage();
  }

  /**
   * Calculate summary metrics based on data
   */
  private async calculateSummaryMetrics(config: FinancialReportPDFConfig, data: any): Promise<Array<{
    label: string;
    value: string;
    change?: string;
  }>> {
    const metrics = [];

    switch (config.reportType) {
      case 'royalty_statements':
        if (data.statements) {
          const totalEarnings = data.statements.reduce((sum: number, s: any) => sum + s.totalEarningsCents, 0);
          const paidStatements = data.statements.filter((s: any) => s.status === 'PAID').length;
          
          metrics.push(
            { label: 'Total Statements', value: data.statements.length.toLocaleString() },
            { label: 'Total Earnings', value: this.formatCurrency(totalEarnings) },
            { label: 'Paid Statements', value: paidStatements.toLocaleString() },
            { label: 'Avg per Statement', value: this.formatCurrency(totalEarnings / data.statements.length) }
          );
        }
        break;

      case 'platform_revenue':
        if (data.licenses) {
          const totalRevenue = data.licenses.reduce((sum: number, l: any) => sum + l.feeCents, 0);
          const uniqueBrands = new Set(data.licenses.map((l: any) => l.brandId)).size;
          
          metrics.push(
            { label: 'Total Revenue', value: this.formatCurrency(totalRevenue) },
            { label: 'Total Licenses', value: data.licenses.length.toLocaleString() },
            { label: 'Unique Brands', value: uniqueBrands.toLocaleString() },
            { label: 'Avg License Value', value: this.formatCurrency(totalRevenue / data.licenses.length) }
          );
        }
        break;
    }

    return metrics;
  }

  /**
   * Generate insights based on report type and data
   */
  private generateInsights(reportType: string, data: any): string[] {
    const insights = [];

    switch (reportType) {
      case 'royalty_statements':
        insights.push(
          'Royalty statement generation and distribution is operating within normal parameters',
          'Creator earnings are distributed according to platform fee structure',
          'All calculations follow the established revenue-sharing agreements'
        );
        break;

      case 'platform_revenue':
        insights.push(
          'Platform revenue reflects licensing activity across all asset categories',
          'Revenue distribution aligns with strategic business objectives',
          'License utilization metrics indicate healthy marketplace activity'
        );
        break;

      default:
        insights.push(
          'Financial data processed according to platform standards',
          'All transactions recorded with full audit trail compliance',
          'Report generated with current platform calculation methodologies'
        );
    }

    return insights;
  }

  /**
   * Get definitions for report type
   */
  private getDefinitionsForReportType(reportType: string): Array<{ term: string; definition: string }> {
    const commonDefs = [
      { term: 'Revenue', definition: 'Total income generated from license fees and platform activities' },
      { term: 'Royalties', definition: 'Earnings distributed to creators based on their IP ownership shares' },
      { term: 'License Fee', definition: 'Amount paid by brands for rights to use creator intellectual property' }
    ];

    const specificDefs: Record<string, Array<{ term: string; definition: string }>> = {
      royalty_statements: [
        { term: 'Statement Period', definition: 'The date range for which royalty earnings are calculated and reported' },
        { term: 'Ownership Share', definition: 'Creator\'s percentage ownership of intellectual property, expressed in basis points' },
        { term: 'Calculated Royalty', definition: 'Creator\'s earnings based on revenue and ownership percentage' }
      ],
      platform_revenue: [
        { term: 'License Type', definition: 'Category of licensing agreement (exclusive, non-exclusive, etc.)' },
        { term: 'Asset Type', definition: 'Classification of intellectual property (music, visual, etc.)' },
        { term: 'Geographic Scope', definition: 'Territorial rights included in licensing agreement' }
      ]
    };

    return [...commonDefs, ...(specificDefs[reportType] || [])];
  }

  /**
   * Generate specific report pages (placeholder methods)
   */
  private async generateRoyaltyStatementsPages(doc: InstanceType<typeof PDFDocument>, data: any) {
    this.addSectionHeader(doc, 'Royalty Statement Details');
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.body)
       .text('Detailed royalty statement data would be rendered here with proper tables and formatting.');
  }

  private async generateTransactionLedgerPages(doc: InstanceType<typeof PDFDocument>, data: any) {
    this.addSectionHeader(doc, 'Transaction Ledger Details');
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.body)
       .text('Detailed transaction ledger data would be rendered here with proper tables and formatting.');
  }

  private async generateCreatorEarningsPages(doc: InstanceType<typeof PDFDocument>, data: any) {
    this.addSectionHeader(doc, 'Creator Earnings Analysis');
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.body)
       .text('Creator earnings analysis would be rendered here with charts and breakdowns.');
  }

  private async generatePlatformRevenuePages(doc: InstanceType<typeof PDFDocument>, data: any) {
    this.addSectionHeader(doc, 'Platform Revenue Analysis');
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.body)
       .text('Platform revenue analysis would be rendered here with trend charts and metrics.');
  }

  private async generatePayoutSummaryPages(doc: InstanceType<typeof PDFDocument>, data: any) {
    this.addSectionHeader(doc, 'Payout Summary Details');
    doc.fillColor(this.brandColors.VOID)
       .fontSize(this.fonts.body)
       .text('Payout summary details would be rendered here with status tracking and reconciliation.');
  }

  /**
   * Format currency values
   */
  private formatCurrency(cents: number): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(cents / 100);
  }
}
